"""Import historical American Express activity into the Spend Tracker DB.

Reads the raw Amex activity text and the parsed CSV (generated by
`amex_activity_parser.py`), infers full dates with years, and inserts
transactions into the SQLite database using SpendDatabase.

- PAYMENT RECEIVED rows are already excluded by the parser.
- Other credits (negative amounts) are preserved as refunds/adjustments.
"""

import csv
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Tuple

# Ensure project root is on sys.path so we can import src.*
ROOT = Path(__file__).resolve().parent.parent
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))

from src.config_loader import load_config
from src.database import SpendDatabase


MONTH_MAP = {
    "Jan": 1,
    "Feb": 2,
    "Mar": 3,
    "Apr": 4,
    "May": 5,
    "Jun": 6,
    "Jul": 7,
    "Aug": 8,
    "Sep": 9,
    "Oct": 10,
    "Nov": 11,
    "Dec": 12,
}


def _parse_end_month_year(raw_text: str) -> Tuple[int, int]:
    """Infer the latest month/year present in the Amex activity.

    We first look for the timestamp at the very top, e.g.:
        "11/19/25, 2:27 AM American Express - Account Activity"

    which is in MM/DD/YY format. If that is not found, we fall back to the
    "Card Activity from ... to ..." header.
    """

    # Try the top timestamp line first (MM/DD/YY, ...)
    m = re.search(r"(\d{1,2})/(\d{1,2})/(\d{2}),", raw_text)
    if m:
        month = int(m.group(1))
        year_2 = int(m.group(3))
        # Assume 20xx for current use case
        year = 2000 + year_2
        return month, year

    # Fallback: Card Activity header
    # Example: "Card Activity from 01-Oct-2024 to 19 Nov" or similar
    m2 = re.search(
        r"Card Activity from\s+\d{1,2}-[A-Za-z]{3}-(\d{4})\s+to\s+(\d{1,2})\s+([A-Za-z]{3})(?:-(\d{4}))?",
        raw_text,
    )
    if m2:
        # If end-year missing, assume same year as start-year
        start_year = int(m2.group(1))
        end_day = int(m2.group(2))
        end_mon_abbr = m2.group(3)[:3].title()
        end_year_group = m2.group(4)
        end_year = int(end_year_group) if end_year_group else start_year
        end_month = MONTH_MAP.get(end_mon_abbr, datetime.now().month)
        return end_month, end_year

    raise RuntimeError("Could not infer latest month/year from Amex activity text")


def _infer_iso_dates(date_strings: List[str], end_month: int, end_year: int) -> List[str]:
    """Convert Amex date strings like '18 Nov' into 'YYYY-MM-DD'.

    Assumes the transactions are listed in reverse-chronological order (newest
    first), which is how the online Amex activity page displays them.

    Algorithm:
    - Start from the known latest month/year (end_month/end_year).
    - For each date in order:
      * If it already contains a year (e.g. '31-Dec-2024'), use it directly.
      * Otherwise, parse 'DD Mon'. If the month is greater than the previous
        month, we have wrapped into the previous year (because we are moving
        backward in time), so decrement the year.
    """

    current_year = end_year
    last_month = end_month
    iso_dates: List[str] = []

    for raw in date_strings:
        s = raw.strip()
        if not s:
            iso_dates.append("")
            continue

        # If it already looks like '31-Dec-2024', parse directly.
        if "-" in s:
            try:
                dt = datetime.strptime(s, "%d-%b-%Y")
                current_year = dt.year
                last_month = dt.month
                iso_dates.append(dt.strftime("%Y-%m-%d"))
                continue
            except ValueError:
                # Fall through to the generic path
                pass

        parts = s.split()
        if len(parts) < 2:
            raise ValueError(f"Unexpected date format: {s!r}")

        day = int(parts[0])
        mon_abbr = parts[1][:3].title()
        month = MONTH_MAP.get(mon_abbr)
        if not month:
            raise ValueError(f"Unknown month in date: {s!r}")

        # If month increases as we move down the list, we've wrapped into the
        # previous year (because the listing is newest-first).
        if month > last_month:
            current_year -= 1

        last_month = month
        dt = datetime(current_year, month, day)
        iso_dates.append(dt.strftime("%Y-%m-%d"))

    return iso_dates


def import_amex_activity_to_db(
    txt_path: Path,
    csv_path: Path,
    db: SpendDatabase,
    card_name: str = "AMEX Platinum Travel",
) -> None:
    """Import parsed Amex activity into the Spend Tracker database."""

    if not txt_path.exists():
        raise FileNotFoundError(f"Raw Amex activity text not found: {txt_path}")
    if not csv_path.exists():
        raise FileNotFoundError(f"Parsed CSV not found: {csv_path}")

    raw_text = txt_path.read_text(encoding="utf-8")
    end_month, end_year = _parse_end_month_year(raw_text)

    print(f"Inferred latest Amex activity date as {end_month:02d}/{end_year} (MM/YYYY)")

    with csv_path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        rows = list(reader)

    if not rows:
        print("No rows found in CSV; nothing to import.")
        return

    date_strings = [row["Date"] for row in rows]
    iso_dates = _infer_iso_dates(date_strings, end_month, end_year)

    transactions = []
    for row, iso_date in zip(rows, iso_dates):
        amount = float(row["Amount"])
        name = row["Name"] or ""
        description = row["Description"] or name

        # Derive statement month/year from the transaction date
        year = int(iso_date[0:4])
        month = int(iso_date[5:7])

        transactions.append(
            {
                "card_name": card_name,
                "transaction_date": iso_date,
                "amount": amount,
                "description": description,
                "category": "",  # can be auto-classified later
                "merchant": name[:50],
                "points": None,
                "classification": "",
                "auto_classified": False,
                "statement_month": f"{month:02d}",
                "statement_year": year,
            }
        )

    print(f"Prepared {len(transactions)} transactions for insertion.")

    before_df = db.get_transactions(card_name=card_name)
    before_count = len(before_df) if before_df is not None else 0

    db.add_transactions_batch(transactions)

    after_df = db.get_transactions(card_name=card_name)
    after_count = len(after_df) if after_df is not None else 0
    inserted = max(after_count - before_count, 0)

    print(f"Inserted ~{inserted} new AMEX transactions (duplicates ignored by UNIQUE constraint).")


def main(argv: List[str]) -> None:
    config = load_config()
    db_path = config["database"]["path"]
    db = SpendDatabase(db_path)

    if len(argv) >= 2:
        txt_path = Path(argv[1])
    else:
        txt_path = Path("data/amex_activity.txt")

    if len(argv) >= 3:
        csv_path = Path(argv[2])
    else:
        csv_path = Path("data/amex_activity_parsed.csv")

    import_amex_activity_to_db(txt_path, csv_path, db)


if __name__ == "__main__":
    main(sys.argv)
